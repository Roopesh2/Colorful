<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Editor</title>
    <link rel="stylesheet" href="../src/style.css" />
    <link rel="stylesheet" href="./myStyle.css" />
    <!-- <script src="https://cdn.jsdelivr.net/gh/Roopesh2/Colorful@master/src/core.js" defer></script>
    <script src="https://cdn.jsdelivr.net/gh/Roopesh2/Colorful@master/src/JavaScript.js" defer></script> -->
    <!-- <script src="../src/core.js" defer></script>
    <script src="../src/JavaScript.js" defer></script> -->
    <script src="../dist/core.js" defer></script>
    <script src="../dist/JavaScript.js" defer></script>
    <script src="./test.js" defer></script>
  </head>
  <body>
    <h1>Colorful</h1>
    <p>A JavaScript library that higlights JavaScript codes</p>
    <p>Examples:</p>
    <div class="container">
      <div class="block">
        <p>Test. Add your code inside pre tag in 23rd line in html code</p>
        <pre class="JS-colorful colorful">var datatypes = {
  numbers: [
    102,
    0.45,
    0xff2,
    0b1001,
    0xff_f2,
    0b10_011110_1101,
    1e34,
    .1e34,
    0.3E2,
    .455,
    .34e3,
    .24e-3,
    24_34E-3,
    24_43.3_454_566,
    24_433_454_566,
    24_433_454_566n,
    24455435893792339433454566n
  ],
  builtInObjects: [
    String, Buffer, Number,
    Error // ...
  ],
  regexp : [
    /abc/,
    /[=+\-*/%!<>&|:?]*/,
    /^(\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?)/,// number regex
    /[w+]/
  ],
  string: [
    "hello",
    'single quote',
    `multiline
    string`,
    `string
    interpolation ${1 != 0}`
  ]
}
re = 4/*'*//*sdfj*//2/6
re = /*'*//*sdfj*//2/6</pre>
      </div>
      <div class="block">
        <p>The source code of this project with line numbers: </p>
        <pre class="JS-colorful colorful" lineNumbering>(function (w) {
    // RegExes
    var KeywordRE =
      /^(await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|implements|import|in|instanceof|interface|let|native|new|null|package|private|protected|public|return|static|super|switch|this|throw|true|try|typeof|undefined|var|void|while|with|yield)$/;
    var operatorRE = /[=+\-*/%!&lt;>&|:?]*/;
    var nameCharRE = /^[\w\u00C0-\uffff\$]+/;
  
    // modified regex from Prism: https://github.com/PrismJS/prism/blob/master/components/prism-javascript.js#L21
    var number =
      /^(\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?)/;
  
    var commentRE = /((\/\*[\s\S]*?\*\/|\/\*[\s\S]*)|(\/\/.*))/;
    var regexRE =
      /^\/((?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+)\/((?:g(?:im?|mi?)?|i(?:gm?|mg?)?|m(?:gi?|ig?)?)?)/;
    // builtIn objects
    var builtInObject =
      /^(AggregateError|Buffer|Array|ArrayBuffer|AsyncFunction|AsyncGenerator|AsyncGeneratorFunction|Atomics|BigInt|BigInt64Array|BigUint64Array|Boolean|DataView|Date|Error|EvalError|Float32Array|Float64Array|Function|Generator|GeneratorFunction|Int16Array|Int32Array|Int8Array|InternalError|Intl|JSON|Map|Math|Number|Object|Promise|Proxy|RangeError|ReferenceError|Reflect|RegExp|Set|SharedArrayBuffer|String|Symbol|SyntaxError|TypeError|URIError|Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|WeakMap|WeakSet|WebAssembly)$/;
    var whitespace = /[\s]+/;
    // types of tokens
    const T_STRING = "STRING",
      T_KEY = "KEY",
      T_TEXT = "TEXT",
      T_OPERATOR = "OPERATOR",
      T_COMMENT = "COMMENT",
      T_NUMBER = "NUMBER",
      T_ARGUMENT = "ARGUMENT",
      T_CAPITAL = "CAPITAL",
      T_OBJECTPROP = "OBJECTPROP",
      T_METHOD = "METHOD",
      T_REGEX = "REGEX",
      T_OTHER = "OTHER";
    // an empty token
    var emptyToken = { type: "", token: "" };
  
    // default configurations for output
    /**
      * combines tokenizer and parser
      * @param {HTMLElement} container
      * @param {Object} cfg
      */
    function highlight(container, cfg = w.Colorful.config) {
      var text = container.innerText;
      var d1 = w.performance.now();
      var out = tokenize(text);
      var markuped = parse(out.tokens);
      var compileTime = w.performance.now() - d1;
      container.innerHTML = w.Colorful.finishUp(cfg, text, markuped);
      var speed = ((text.length / 1024 / compileTime) * 1000).toFixed(3); //kb/s
      console.log(
        `total code analysed: ${(text.length / 1024).toFixed(3)} KiB\nfound: ${
          out.tokens.length
        } tokens\ncompile time: ${compileTime.toFixed(
          4
        )} ms\ncompile speed: ${speed} KiB/s`
      );
    }
  
    /**
      * tokenize input text
      * @param {String} text text to be tokenised
      * @param {Object} [ErrHandler={}] defines how errors should be handled.
      * Only handles bracket/brace/paren un matches only in one way: either break and return tokens or continue.
      *
      * possible values: {
      *  breakOnBraceUnmatch: true/false,
      *  breakOnParenUnmatch: true/false,
      *  breakOnBracketUnmatch: true/false
      * }
      * @return {Object}
      *
      * @example tokenize("...", { breakOnBraceUnmatch:true }) // returns tokens when brace not matches or EOF reached
      */
    function tokenize(text, ErrHandler = {}) {
      var len = text.length;
      var tokens = [],
        word = "",
        scopeTree = [], // list like structure defines where current tokenisation is happening
        scope = "empty"; // recent scope
      var i = 0;
      while (i &lt; len) {
        word = text.substring(i).match(nameCharRE);
        var isNum, prevTkn;
        if (word) {
          var v = word[0];
          isNum = v.match(number);
          prevTkn = tokens[tokens.length - 1] || emptyToken;
          if (isNum) {
            v = text.substring(i).match(number)[0];
            addToken(T_NUMBER, v);
          } else {
            readWordToken(v);
          }
          i += v.length;
          window.Colorful.mergeSameTypes(tokens);
        } else if (text[i] == "." && /\d/.test(text[i + 1])) {
          var w = text.substring(i).match(number)[0];
          addToken(T_NUMBER, w);
          i += w.length;
        }
        if (i == len) break; // break if EOF
        prevTkn = tokens[tokens.length - 1] || emptyToken; // previous token
        /* after matching a word there will be a non-unicode characters (punctuations, operators, etc.) that will follow word. Following code analyses it */
        var char = text[i]; // next character
        var next2 = text.substr(i, 2); // next two characters
  
        if (whitespace.test(char)) {
          // finds next whitespace characters
          var space = text.substring(i).match(whitespace)[0];
          if (prevTkn.token) prevTkn.token += space;
          // if a token exists in the list add whitespaces to it
          else addToken(T_TEXT, space); // if there is no previous tokens
          i += space.length;
        } else if (char == "'" || char == '"' || char == "`") {
          // string ahead
  
          addToken(T_STRING, char);
          i++;
  
          var str = "";
          var slashes = 0; // number of backslashes
          //regular expression that is used to match all characters except the string determiner and backslashes
          var re =
            char == "'" ? /^[^'\\]+/ : char == '"' ? /^[^"\\]+/ : /^[^`\\${]+/;
          while (i &lt; len) {
            str = text.substring(i).match(re);
            if (str) {
              addToken(T_STRING, str[0]);
              i += str[0].length;
              slashes = 0;
            }
            var ch = text[i];
            if (ch == "\\") {
              var slsh = text.substring(i).match(/[\\]+/)[0];
              addToken(T_STRING, slsh);
              slashes += slsh.length;
              i += slsh.length;
            } else if (ch == char) {
              addToken(T_STRING, ch);
              i++;
              if (slashes % 2 == 0) break; // even number of #backslashes means string character is not escaped
            } else if (text.substr(i, 2) == "${") {
              // only for multiline string
              // string interpolation ahead
              addToken(T_OPERATOR, "${"); // adds `${` as operator
              i += 2;
              var nxt = text.substring(i); // text left to parse except `${`
              var out = tokenize(nxt, { breakOnBraceUnmatch: true }); // tokenises code left
              if (out.tokens.length) tokens = tokens.concat(out.tokens);
              i += out.inputEnd;
              if (out.inputEnd != nxt.length) {
                // if tokenization was completed due to an unmatched brace add `}` after everything
                addToken(T_OPERATOR, "}");
                i++;
              } else if (text[i - 1] == "\n") {
                tokens[tokens.length - 1].token += "\n"; // quick fix
              }
            }
          }
        } else if (char.match(operatorRE)[0]) {
          var nxt = text.substring(i);
          var prevt = prevTkn.type;
          if (next2 == "//" || next2 == "/*") {
            // comment ahead
            var comment = nxt.match(commentRE)[0];
            i += comment.length;
            addToken(T_COMMENT, comment);
          } else if (
            char == "/" &&
            !(prevt == T_TEXT || prevt == T_OBJECTPROP || prevt == T_NUMBER) &&
            regexRE.test(nxt)
          ) {
            // regular expression ahead
            var regExAhead = true;
            var tk = tokens[tokens.length - 2].type;
            if (
              prevTkn.type == T_COMMENT &&
              (tk == T_TEXT || tk == T_OBJECTPROP || tk == T_NUMBER)
            ) {
              regExAhead = false;
            }
            if (regExAhead) {
              var re = nxt.match(regexRE)[0];
              addToken(T_REGEX, re);
              i += re.length;
            } else {
              //operator
              addToken(T_OPERATOR, char);
              i++;
            }
          } else if (next2 == "=>") {
            if (prevTkn.type == "TEXT") {
              prevTkn.type = "ARGUMENT";
            } else if (/\)\s*$/.test(prevTkn.token)) {
              var initialScopeLevel = scopeTree.length;
              var argsarr = [tokens[tokens.length - 1]];
              for (var k = tokens.length - 2; k >= 0; k--) {
                var tk = tokens[k];
                argsarr.push(tk);
                if (tk.type == T_OTHER && tk.scopeLevel == initialScopeLevel) {
                  tokens.splice(k);
                  break;
                }
              }
              argsarr.reverse();
              readArgumentsInTokens(argsarr, initialScopeLevel + 1, false);
            }
            addToken(T_OPERATOR, next2);
            i += 2;
          } else {
            //operator
            addToken(T_OPERATOR, char);
            i++;
          }
        } else if (char == "(") {
          // function name
          var prev = prevTkn;
          var prevt = prev.type;
          var pprev = tokens[tokens.length - 2] || emptyToken;
          const isFunctionClause =
            (prev.token.substr(0, 8) == "function" && prevt == "KEY") ||
            (pprev.token.substr(0, 8) == "function" && pprev.type == "KEY") ||
            scopeTree[scopeTree.length - 1] == "class";
          addToken(T_OTHER, "(");
          i++;
          scopeTree.push("(");
          scope = "(";
          // makes name of function colored to method
          if (prevt == "TEXT" || prevt == "OBJECTPROP") {
            prev.type = T_METHOD;
          }
          if (isFunctionClause && next2 != "()") {
            // reads arguments
            var tkn = tokenize(text.substring(i), { breakOnParenUnmatch: true });
            var tkns = tkn.tokens;
            readArgumentsInTokens(tkns);
            i += tkn.inputEnd;
          }
        } else if (char == "{" || char == "[") {
          addToken("OTHER", char);
          i++;
          scopeTree.push(scope);
          scope = char;
        } else if (char == "}" || char == ")" || char == "]") {
          var handler = {
            "}": "breakOnBraceUnmatch",
            ")": "breakOnParenUnmatch",
            "]": "breakOnBracketUnmatch",
          };
          if (scopeTree.length > 0) {
            scopeTree.pop();
          } else if (ErrHandler[handler[char]]) {
            break;
          }
          addToken("OTHER", char);
          i++;
        } else {
          addToken("OTHER", char);
          i++;
        }
        window.Colorful.mergeSameTypes(tokens);
      }
      if (char == "\n") tokens[tokens.length - 1].token += "\n"; // quick fix
      return { tokens: tokens, inputEnd: i };
      function addToken(type, token) {
        tokens.push({
          type: type,
          token: token.replaceSpecHTMLChars(),
          scopeLevel: scopeTree.length,
        });
      }
  
      // read arguments
      function readArgumentsInTokens(tks, base = 0, increase = true) {
        for (var k = 0; k &lt; tks.length; k++) {
          var tk = tks[k];
          if (
            (tk.type == T_TEXT || tk.type == T_CAPITAL) &&
            tk.scopeLevel == base &&
            tks[k - 1]?.type != T_OPERATOR
          ) {
            tk.type = T_ARGUMENT;
          }
          if (increase) tk.scopeLevel++;
        }
        tokens = tokens.concat(tks);
      }
  
      // finds the type of word given
      function readWordToken(word) {
        var pprevt = tokens[tokens.length - 2]?.token || "";
        var prevt = prevTkn.token || "";
        if (
          KeywordRE.test(word) || // global keywords
          (word == "arguments" &&
            scopeTree[scopeTree.length - 1] == "function") || // argument inside function clause
          ((word == "get" || word == "set") &&
            scopeTree[scopeTree.length - 1] == "class") // get/set inside class scope
        ) {
          // Keyword
          if (
            /(function|if|do|while|for|class|catch|else|finally|switch|try|)/.test(
              word
            )
          ) {
            scope = word;
          }
          addToken(T_KEY, word);
        } else if (number.test(word)) {
          addToken(T_NUMBER, word);
        } else if (
          builtInObject.test(word) &&
          !/^(function|var|const|let)/.test(prevt) &&
          prevt[0] != "."
        ) {
          // builtin objects word
          addToken(T_CAPITAL, word);
        } else if (/(\.)(\s*)$/.test(prevt) || pprevt.endsWith(".")) {
          // object property
          addToken(T_OBJECTPROP, word);
        } else {
          addToken(T_TEXT, word);
        }
      }
    }
  
    /**
      * parse tokens to generate html string
      * @param {Array} tokens array of tokens
      * @return {String}
      */
    function parse(tokens) {
      var formatted = ``;
      var d = {
        TEXT: "name",
        OBJECTPROP: "objprop",
        KEY: "keyword",
        COMMENT: "comment",
        NUMBER: "number",
        ARGUMENT: "argument",
        CAPITAL: "capital",
        METHOD: "method",
        STRING: "string",
        REGEX: "regex",
        OPERATOR: "operator",
      };
      for (var i = 0; i &lt; tokens.length; i++) {
        var tkn = tokens[i],
          tokenType = tkn.type;
        if (tokenType != "OTHER") {
          formatted +=
            "&lt;span class='" + d[tokenType] + "'>" + tkn.token + "&lt;/span>";
        } else {
          formatted += tkn.token;
        }
      }
      return formatted;
    }
  
    w.Colorful.langs.push("JS");
    w.Colorful.compilers.JS = {
      compile: highlight,
      tokenize: tokenize,
      parse: parse,
    };
  })(window);</pre>
      </div>
  </body>
</html>