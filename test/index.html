<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Editor</title>
    <link rel="stylesheet" href="../src/style.css" />
    <link rel="stylesheet" href="./myStyle.css" />
    <script src="../src/JS-syntex-min.js" defer></script>
    <!-- <script src="../src/complete.js" defer></script> -->
  </head>
  <body>
    <h1>SynTexer Test</h1>
    <p>below codes test this library</p>
    <div class="container">
      <div class="block">
        <p>Adding two numners</p>
        <div class="ex1 js-syntex" fontsize="23" lineheight="26">var var1 = add(1, 2);
function add(a, b) {
  return a + b;
}
        </div>
      </div>
      <div class="block">
        <p>Regex test</p>
        <div class="ex2 js-syntex">var Keyword =
  /^(arguments|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|eval|export|extends|false|finally|for|function|if|implements|import|in|instanceof|interface|let|native|new|null|package|private|protected|public|return|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)$/;
var operator = /(\=|\+|\-|\*|\/|%|!|<|>|&|\|)*/;

// variable or funciton names
var nameChar = /[a-zA-Z0-9_\$]/;
var number = /^((\d*)|(0x[0-9a-f]*)|(0b[01]*))$/;
var nullTypes = /^(null|NaN|undefined)$/;
// Test
"234".match(nameChar)
        </div>
        
      </div>
      <div class="block">
        <p>Overall test</p>
        <div class="ex3 js-syntex">var config = {
          tabIndex: 4,
          fontSize: 16, // in px
          enableLineNumbering: true,
          performanceMonitoring: true
        }
        String.prototype.reverse = function () {
          return this.split("").reverse().join("");
        };
        const [
          T_STRING,
          T_KEY,
          T_TEXT,
          T_OPERATOR,
          T_NEWLINE,
          T_COMMENT,
          T_NUMBER,
          T_WS,
          T_FUNCTION,
          T_ARGUMENT,
          T_CAPITAL,
          T_OBJECTPROP,
          T_METHOD,
          T_REGEX,
          T_LPAREN,
          T_NULLTYPE
        ] = [
          "STRING",
          "KEY",
          "TEXT",
          "OPERATOR",
          "NEWLINE",
          "COMMENT",
          "NUMBER",
          "WS",
          "FUNCTION",
          "ARGUMENT",
          "CAPITAL",
          "OBJECTPROP",
          "METHOD",
          "REGEX",
          "PAREN",
          "NULLTYPE"
        ];
        var emptyToken = {type: "", token:""};
        
        // RegEx
        var KeywordRE =
          /^(arguments|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|eval|export|extends|false|finally|for|function|if|implements|import|in|instanceof|interface|let|native|new|null|package|private|protected|public|return|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)$/;
        var operatorRE = /(\=|\+|\-|\*|\/|%|!|<|>|&|\|)*/;
        var nameCharRE = /[a-zA-Z0-9_\$]/;
        var number = /^((\d*)|(0x[0-9a-f]*)|(0b[01]*))$/;
        var nullTypes = /^(null|NaN|undefined)$/;
        var commentRE = /((\/\*[\s\S]*?\*\/|\/\*[\s\S]*)|(\/\/.*))/;
        var stringRE =
          /('(((\\)+(')?)|([^']))*')|("(((\\)+(")?)|([^"]))*")|(`(((\\)+(`)?)|([^`]))*`)/;
        var regexRE =
          /^\/((?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+)\/((?:g(?:im?|mi?)?|i(?:gm?|mg?)?|m(?:gi?|ig?)?)?)/;
        var txt_obj = /(TEXT|OBJECTPROP)/
        var builtInObject =
          /^(AggregateError|Buffer|Array|ArrayBuffer|AsyncFunction|AsyncGenerator|AsyncGeneratorFunction|Atomics|BigInt|BigInt64Array|BigUint64Array|Boolean|DataView|Date|Error|EvalError|Float32Array|Float64Array|Function|Generator|GeneratorFunction|Int16Array|Int32Array|Int8Array|InternalError|Intl|JSON|Map|Math|Number|Object|Promise|Proxy|RangeError|ReferenceError|Reflect|RegExp|Set|SharedArrayBuffer|String|Symbol|SyntaxError|TypeError|URIError|Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|WeakMap|WeakSet|WebAssembly)$/;
        
        //global variables for functionalities
        var lineCount = 1;
        var w_h = 0.5498367766955267; // width/height of a monospace number
        var numberWidth = w_h * config.fontSize;
        
        function highlight(container, text) {
          var d1 = window.performance.now();
          var tokens = tokenise(text);
          var markuped = parseToken(tokens);
          var compileTime = window.performance.now() - d1;
          var totalTime = window.performance.now() - d1;
          if (config.performanceMonitoring) {
            console.log(`total code analysed: ${(len/1024).toFixed(3)} kb
        found: ${tokens.length} tokens
        compile time: ${compileTime.toFixed(4)} ms
        compile speed: ${((len/1024/compileTime) * 1000).toFixed(3)} kib/s
        total time: ${totalTime.toFixed(4)} ms`)
          }
          return tokens;
        }
        
        function tokenise(text) {
          len = text.length;
          var tokens = [],
            word = "";
        
          for (var i = 0; i < len; i++) {
            var char = text[i];
            // debugger
            if (!char.match(nameCharRE)) {
              // word analysis
              if (word != "") {
                tokens.push(readWordToken(word));
                //  mergeSameTypes();
              }
              var next2 = text.substring(i, i + 2);
              // analysin various symbols
        
              if (char == "\n") {
                tokens.push({type: T_NEWLINE});
              } else if (next2 == "//" || next2 == "/*") {
                // comment
                var comment = text.substring(i, len).match(commentRE)[0];
                i += comment.length - 1;
                comment = comment.replaceSpecHTMLChars().split("\n");
                comment.forEach((line, index) => {
                  tokens.push({ type: T_COMMENT, token: line});
                  if (index < comment.length-1) tokens.push({ type: T_NEWLINE});
                });
                // tokens.push({ type: T_COMMENT, token: d});
              } else if (char.match(/['"`]/)) {
                var str = text.substring(i, len).match(stringRE)[0];
                i += str.length - 1;
                tokens.push({ type: T_STRING, token: str.replaceSpecHTMLChars() });
              } else if (char.match(operatorRE)[0]) {
                // math operators
                if (char == "/") {
                  var re = text.substring(i, len).match(regexRE);
                  if (re) {
                    tokens.push({ type: T_REGEX, token: re[0] });
                    i += re[0].length;
                  }
                }
                var operStr = text.substring(i).match(operatorRE)[0];
                i += operStr.length - 1;
                tokens.push({
                  type: T_OPERATOR,
                  token: operStr.replaceSpecHTMLChars(),
                });
              } else if (char == "(") {
                // function name
                var tl = tokens.length;
                var prev = tokens[tl - 1] || emptyToken;
                var prevt = prev.token;
                var pprev = tokens[tl - 2] || emptyToken;
                var ppprev = tokens[tl - 3] || emptyToken;
                tokens.push({ type: T_LPAREN, token: "(" });
                const isFunctionClause =
                  prevt == "function" ||
                  pprev.token == "function" ||
                  ppprev.token == "function";
                /** if following condition is true then it would be function clause
                 * cases:
                 * 1: function name (args)
                 * 2: function name(args)
                 * 3: function (args)
                 * 4: function(args)
                 */
                if (isFunctionClause) {
                  // makes name of function colored to method
                  if (prev.type == T_TEXT && prevt.match(nameCharRE)) {
                    prev.type = T_METHOD;
                  } else if (pprev.type == T_TEXT && pprev.token.match(nameCharRE)) {
                    pprev.type = T_METHOD;
                  }
        
                  // reads arguments
                  if (next2 != "()") {
                    [args, i] = readArgumentsToken(i);
                    tokens = tokens.concat(args);
                  }
                } else if (
                  prevt.match(nameCharRE) &&
                  /[a-zA-Z0-9_$\s]+/.test(
                    (prevt.reverse().match(/^(\s)*[a-zA-Z0-9_$\s]+/) || [""])[0]
                  )
                ) {
                  //this is function calling clause
                  if (prev.type.match(txt_obj) && prevt.match(nameCharRE)) {
                    prev.type = T_FUNCTION;
                  } else if (
                    pprev.type.match(txt_obj) &&
                    pprev.token.match(nameCharRE)
                  ) {
                    pprev.type = T_FUNCTION;
                  } else if (
                    ppprev.type.match(txt_obj) &&
                    ppprev.token.match(nameCharRE)
                  ) {
                    ppprev.type = T_FUNCTION;
                  }
                }
              } else {
                tokens.push({ type: T_TEXT, token: char });
              }
              word = "";
            } else if (char.match(nameCharRE)) {
              word += char;
            }
            mergeSameTypes();
          }
          if (word != "") tokens.push(readWordToken(word));
          return tokens;
        
          /*
          merges same type of consecutive tokens (except NEWLINE) into
          single one to minimize tokens to parse
          */
          function mergeSameTypes() {
            var tl = tokens.length;
            if (
              tl > 1 &&
              tokens[tl - 1].type == tokens[tl - 2].type && tokens[tl - 1].type != T_NEWLINE
            ) {
              tokens[tl - 2].token += tokens[tl - 1].token;
              tokens.pop();
            }
          }
          function readArgumentsToken(k) {
            // reads and finds arguments of a function being defined
            var args = text.substring(k + 1).match(/[^)]*/)[0];
            const index = args.length + 1;
            var argarr = [];
            var w = "";
            for (var l = 0; l < args.length; l++) {
              var ch = args[l]
              if (ch.match(nameCharRE)) {
                w += ch
              } else {
                if (ch.match(/[\t ]/)) {
                  w += ch;
                  continue
                } else {
                  argarr.push({type: T_ARGUMENT, token: w});
                  if (ch == "\n") argarr.push({type: T_NEWLINE});
                  w = "";
                }
              }
            }
            if (text[k + index] == ")") argarr.push({ type: T_TEXT, token: ")" }); // adds right paren if it was there
            return [argarr, index + k];
          }
        
          // finds the type of word given
          function readWordToken(word) {
            try {
              tokens[tokens.length - 1]?.token[0] != "."
            } catch (error) {
              console.log(252, tokens[tokens.length-1])
            }
            if (word.match(KeywordRE)) {
              // Keyword
              return { type: T_KEY, token: word };
            } else if (word.match(number)) {
              // a number
              return { type: T_NUMBER, token: word };
            } else if (
                word.match(builtInObject) &&
                tokens[tokens.length - 2]?.token != "function" &&
                (tokens[tokens.length - 1]?.token || "")[0] != "."
            ) {
                // builtin objects word 
                //eg: Buffer, Array, String, ...
                return { type: T_CAPITAL, token: word };
            } else if (
              (tokens[tokens.length - 1]?.token || "").endsWith(".") ||
              (tokens[tokens.length - 2]?.token || "").endsWith(".")
            ) {
              return { type: T_OBJECTPROP, token: word };
            } else if (word.match(nullTypes)) {
              return { type: T_NULLTYPE, token: word };
            } else {
              return { type: T_TEXT, token: word };
            }
          }
        }</div>
      </div>
    </div>
  </body>
</html>
